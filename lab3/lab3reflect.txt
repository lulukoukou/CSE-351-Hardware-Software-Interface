********************
* Lab 3 Reflection *
********************
Name: QIHAN ZHAO
ID:   1726473


-----------------------------------------------------------
1) Instruction 1: <fillArray + 4> sub    $0x20,%rsp
   Purpose:    %rsp - 0x20 is the space that assigned to this function in the stack.
	       0x20 = 32 is the total space remained for the fillArray function to store data.

   Instruction 2: < part2 + 18> lea    -0x30(%rbp),%rax
   Purpose: 0x 30 = 48, 48 / 4 (int size) = 12, part 2 restricts the array size to be less than 12.
-----------------------------------------------------------
2) Explain:  
Alghough C does not do boundary check, the input length requests to access the memory, which is actually outside the length of array. This kind of bad access to the memory causes the segmentation fault.

The pointer array get corrputed, the instuction "mov    %rsp,%rbp" causes the segmentation fault to occur. (I do understand that the segfault is caused by that pointer points to the bad memory but not sure the detail. This instruction restores the address and moves stack pointer to another register. However, based on my understanding, the stack pointer has been corrputed and pointed to bad memory.)

-----------------------------------------------------------
3) Explain:  
No, I do not agree.

The segmentation fault happens due to the bad access to memory.
Even if the array is stored in the heap, which stores data from low address to high address, you are still trying to access the array outside it's length/boundary and request the bad access to memory as well. On the other word, if the pointer points to the invalid memory address, it will cause segmentation fault anyway.



-----------------------------------------------------------
